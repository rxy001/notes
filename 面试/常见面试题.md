#### 从输入url到页面展示，中间发生了什么

首先由网络进程检查浏览器本地资源缓存，如果缓存可用则直接使用，没有则通过dns获取ip地址，与目的服务器经过三次握手构建tcp连接，然后发送http请求，接收数据，4次挥手断开连接。之后网络进程会解析响应头，状态码为301或者302，会重定向到新的地址。content-type 是字节流类型则交给下载管理器，如果是text/html，则把数据传给渲染进程，渲染进程会去解析html.css.js，生成dom tree，然后计算节点的样式和几何位置，再生成layout tree。由于页面中有很多复杂的动画效果或者z-index层叠顺序或者裁剪滚动等，渲染进程还会为特定的节点生成专用的图层，结合形成layer tree。之后开始对图层树中的每个图层生成绘制指令，由合成线程生成位图，再由浏览器主进程显示到页面中。



#### css js 阻塞

1. css加载不会阻塞dom树的构建。
2. css加载会阻塞页面渲染。
3. css加载会阻塞后面js语句的执行。
4. js执行和非异步的外联Js文件加载会阻塞dom树的构建。



#### DOMContentLoaded 触发时机

1. 如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行。
2. 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。



#### 原型链

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/84d8810caa3349e989a3a6c1de44f52a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



#### `async defer` 区别

`defer async` 类型脚本的加载不会阻塞页面渲染。` defer `是在 dom 树构建完成之后，`DOMContentLoaded` 事件之前执行。 当有多个脚本设置`defer`时，将按照文档中的顺序执行。 ` async`只要加载完成就立即执行，不会等待其他脚本或者 dom 树构建之后。



#### CommonJS vs ES Module

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有一个独立的模块依赖的解析阶段。





#### 闭包

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。

浏览器内部闭包的实现：

1. 当 JavaScript 引擎执行到函数 `outer_fn`时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 `inner_fn`，JavaScript 引擎还要对 `inner_fn`做一次快速的词法扫描，发现`inner_fn`引用了 `outer_fn`中的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“`closure(outer_fn)`”的对象（这是一个内部对象，JavaScript 是无法访问的，但在 `chrome_devtool`的 `source` 可访问），用来保存被引用的变量。
3. `outer_fn`执行结束，`closure(outer_fn)`依然存在堆空间里。当`inner_fn`调用时，创建的执行上下文中变量对象就包含了 `closure(outer_fn)` 。

